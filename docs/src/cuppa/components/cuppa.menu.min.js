/**
 * v0.0.11
 * Authors (https://github.com/cloudbit-interactive/cuppajs)
 * Licensed under MIT (https://github.com/cloudbit-interactive/cuppajs/blob/main/LICENSE)
 */
/*! v0.0.8 */
export class CuppaComponent extends HTMLElement{refs={};shadow=null;renderedCount=0;_template;_callbacks=[];constructor(){super(),this.getPropertiesCallbacks(),this.binAll=this.binAll.bind(this),this.connectedCallback=this.connectedCallback.bind(this),this.forceRender=this.forceRender.bind(this),this.disconnectedCallback=this.disconnectedCallback.bind(this),this.observables=this.observables.bind(this),this.applyObservables=this.applyObservables.bind(this),this.applyObservables(),this.binAll(this)}static get observedAttributes(){return this.attributes||[]}attributeChangedCallback(t,e,s){e!==s&&("false"===s&&(s=!1),"true"===s&&(s=!0),this[camelize(t)]=s)}applyObservables(){this.constructor.observables&&setTimeout((()=>{let t={};for(let e=0;e<this.constructor.observables.length;e++){let s=this.constructor.observables[e];t[s]=this[s]}this.observables(t),this.forceRender()}),0)}getPropertiesCallbacks(){let t=Object.entries(this);for(let e=0;e<t.length;e++){let[s,i]=t[e];-1===["refs","shadow","renderedCount","_template","_callbacks"].indexOf(s)&&this._callbacks.push({key:s,value:i})}}reSetPropertiesCallbacks(){for(let t=0;t<this._callbacks.length;t++){let{key:e,value:s}=this._callbacks[t];this[e]=s}}connectedCallback(){this.reSetPropertiesCallbacks(),this.shadow&&this.attachShadow({mode:this.shadow}),this.forceRender(null,!1),this.rendered&&this.rendered(this.renderedCount,this),setTimeout((()=>{this.applyStylesAfterRender(),this.mounted&&this.mounted(this)}),0)}applyStylesAfterRender(){const t=this.getAttribute("style-after-render");if(t)for(const e of t.split(";")){const[t,s]=e.split(":");t&&s&&(this.style[t.trim()]=s.trim())}}disconnectedCallback(){this.unmounted&&this.unmounted(this)}setVariables(t){Object.entries(t).map((([t,e])=>{this[`${t}`]=e})),this.forceRender()}forceRender(t=null,e=!0){this._template||(this._template=()=>this.render()),this.shadowRoot?render(this._template(),this.shadowRoot):render(this._template(),this),this.processRefs(this,this.refs,"ref"),t&&t(),this.renderedCount++,this.firstRendered&&1===this.renderedCount&&this.firstRendered(this.renderedCount,this),this.rendered&&e&&this.rendered(this.renderedCount,this)}processRefs(t,e,s){s||(s="id");let i={},n=Array.from(t.querySelectorAll(`[${s}]`));for(let t=0;t<n.length;t++)e?e[n[t].getAttribute(s)]=n[t]:i[n[t].getAttribute(s)]=n[t];return e?e.rootHtml=t:i.rootHtml=t,i}binAll(t,e){let s=Object.getOwnPropertyNames(Object.getPrototypeOf(t));e&&(s=Object.keys(t));for(let e=0;e<s.length;e++)"constructor"!==s[e]&&"function"==typeof t[s[e]]&&(t[s[e]]=t[s[e]].bind(t))}bind(t){let e=Object.getOwnPropertyNames(Object.getPrototypeOf(t));for(let s=0;s<e.length;s++)if("function"==typeof t[e[s]]){if(this[e[s]])continue;this[e[s]]=t[e[s]].bind(t)}}observables(t,e){let s,i=this;if(t){if(!Array.isArray(t))return Object.keys(t).map(((n,r)=>{r||(s=n);let o=t[n],l="_"+n;i[l]=o,Object.defineProperty(i,n,{set:t=>{i[l]=t,i.forceRender&&i.forceRender(),e&&e()},get:()=>i[l],configurable:!0})})),i[s];t.forEach((t=>{this.observable(t,this[t])}))}}observable(t,e){return setTimeout((()=>{e&&void 0===this[t]||(e=this[t]),this.observables({[t]:e})}),0),e}}export function camelize(t){return(t=(t=(t=(t=(t=String(t)||"").replace(new RegExp("-","g")," ")).replace(new RegExp("_","g")," ")).toLowerCase()).replace(/[^\w\s]/gi,"")).replace(/(?:^\w|[A-Z]|\b\w|\s+)/g,(function(t,e){return 0==+t?"":0===e?t.toLowerCase():t.toUpperCase()}))}var t,e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},i={};e.d(i,{BJ:()=>tt,Al:()=>O,dy:()=>b,Jb:()=>M,Ld:()=>w,sY:()=>W,rx:()=>X,YP:()=>N,Au:()=>et});const s=window,n=s.trustedTypes,o=n?n.createPolicy("lit-html",{createHTML:t=>t}):void 0,r="$lit$",l=`lit$${(Math.random()+"").slice(9)}$`,h="?"+l,a=`<${h}>`,d=document,$=()=>d.createComment(""),c=t=>null===t||"object"!=typeof t&&"function"!=typeof t,u=Array.isArray,A=t=>u(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]),_="[ \t\n\f\r]",v=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,p=/-->/g,f=/>/g,g=RegExp(`>|${_}(?:([^\\s"'>=/]+)(${_}*=${_}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),m=/'/g,y=/"/g,x=/^(?:script|style|textarea|title)$/i,H=t=>(e,...s)=>({_$litType$:t,strings:e,values:s}),b=H(1),N=H(2),M=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,C=d.createTreeWalker(d,129,null,!1),S=(t,e)=>{const s=t.length-1,i=[];let n,h=2===e?"<svg>":"",d=v;for(let e=0;e<s;e++){const s=t[e];let o,c,u=-1,$=0;for(;$<s.length&&(d.lastIndex=$,c=d.exec(s),null!==c);)$=d.lastIndex,d===v?"!--"===c[1]?d=p:void 0!==c[1]?d=f:void 0!==c[2]?(x.test(c[2])&&(n=RegExp("</"+c[2],"g")),d=g):void 0!==c[3]&&(d=g):d===g?">"===c[0]?(d=null!=n?n:v,u=-1):void 0===c[1]?u=-2:(u=d.lastIndex-c[2].length,o=c[1],d=void 0===c[3]?g:'"'===c[3]?y:m):d===y||d===m?d=g:d===p||d===f?d=v:(d=g,n=void 0);const A=d===g&&t[e+1].startsWith("/>")?" ":"";h+=d===v?s+a:u>=0?(i.push(o),s.slice(0,u)+r+s.slice(u)+l+A):s+l+(-2===u?(i.push(void 0),e):A)}const c=h+(t[s]||"<?>")+(2===e?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return[void 0!==o?o.createHTML(c):c,i]};class B{constructor({strings:t,_$litType$:e},s){let i;this.parts=[];let o=0,a=0;const d=t.length-1,c=this.parts,[u,p]=S(t,e);if(this.el=B.createElement(u,s),C.currentNode=this.el.content,2===e){const t=this.el.content,e=t.firstChild;e.remove(),t.append(...e.childNodes)}for(;null!==(i=C.nextNode())&&c.length<d;){if(1===i.nodeType){if(i.hasAttributes()){const t=[];for(const e of i.getAttributeNames())if(e.endsWith(r)||e.startsWith(l)){const s=p[a++];if(t.push(e),void 0!==s){const t=i.getAttribute(s.toLowerCase()+r).split(l),e=/([.?@])?(.*)/.exec(s);c.push({type:1,index:o,name:e[2],strings:t,ctor:"."===e[1]?L:"?"===e[1]?R:"@"===e[1]?j:U})}else c.push({type:6,index:o})}for(const e of t)i.removeAttribute(e)}if(x.test(i.tagName)){const t=i.textContent.split(l),e=t.length-1;if(e>0){i.textContent=n?n.emptyScript:"";for(let s=0;s<e;s++)i.append(t[s],$()),C.nextNode(),c.push({type:2,index:++o});i.append(t[e],$())}}}else if(8===i.nodeType)if(i.data===h)c.push({type:2,index:o});else{let t=-1;for(;-1!==(t=i.data.indexOf(l,t+1));)c.push({type:7,index:o}),t+=l.length-1}o++}}static createElement(t,e){const s=d.createElement("template");return s.innerHTML=t,s}}function P(t,e,s=t,i){var n,r,o,l;if(e===M)return e;let h=void 0!==i?null===(n=s._$Co)||void 0===n?void 0:n[i]:s._$Cl;const a=c(e)?void 0:e._$litDirective$;return(null==h?void 0:h.constructor)!==a&&(null===(r=null==h?void 0:h._$AO)||void 0===r||r.call(h,!1),void 0===a?h=void 0:(h=new a(t),h._$AT(t,s,i)),void 0!==i?(null!==(o=(l=s)._$Co)&&void 0!==o?o:l._$Co=[])[i]=h:s._$Cl=h),void 0!==h&&(e=P(t,h._$AS(t,e.values),h,i)),e}class E{constructor(t,e){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=e}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){var e;const{el:{content:s},parts:i}=this._$AD,n=(null!==(e=null==t?void 0:t.creationScope)&&void 0!==e?e:d).importNode(s,!0);C.currentNode=n;let r=C.nextNode(),o=0,l=0,h=i[0];for(;void 0!==h;){if(o===h.index){let e;2===h.type?e=new I(r,r.nextSibling,this,t):1===h.type?e=new h.ctor(r,h.name,h.strings,this,t):6===h.type&&(e=new D(r,this,t)),this._$AV.push(e),h=i[++l]}o!==(null==h?void 0:h.index)&&(r=C.nextNode(),o++)}return n}v(t){let e=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,e),e+=s.strings.length-2):s._$AI(t[e])),e++}}class I{constructor(t,e,s,i){var n;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=e,this._$AM=s,this.options=i,this._$Cp=null===(n=null==i?void 0:i.isConnected)||void 0===n||n}get _$AU(){var t,e;return null!==(e=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==e?e:this._$Cp}get parentNode(){let t=this._$AA.parentNode;const e=this._$AM;return void 0!==e&&11===(null==t?void 0:t.nodeType)&&(t=e.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,e=this){t=P(this,t,e),c(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==M&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):A(t)?this.T(t):this._(t)}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t))}_(t){this._$AH!==w&&c(this._$AH)?this._$AA.nextSibling.data=t:this.$(d.createTextNode(t)),this._$AH=t}g(t){var e;const{values:s,_$litType$:i}=t,n="number"==typeof i?this._$AC(t):(void 0===i.el&&(i.el=B.createElement(i.h,this.options)),i);if((null===(e=this._$AH)||void 0===e?void 0:e._$AD)===n)this._$AH.v(s);else{const t=new E(n,this),e=t.u(this.options);t.v(s),this.$(e),this._$AH=t}}_$AC(t){let e=T.get(t.strings);return void 0===e&&T.set(t.strings,e=new B(t)),e}T(t){u(this._$AH)||(this._$AH=[],this._$AR());const e=this._$AH;let s,i=0;for(const n of t)i===e.length?e.push(s=new I(this.k($()),this.k($()),this,this.options)):s=e[i],s._$AI(n),i++;i<e.length&&(this._$AR(s&&s._$AB.nextSibling,i),e.length=i)}_$AR(t=this._$AA.nextSibling,e){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,e);t&&t!==this._$AB;){const e=t.nextSibling;t.remove(),t=e}}setConnected(t){var e;void 0===this._$AM&&(this._$Cp=t,null===(e=this._$AP)||void 0===e||e.call(this,t))}}class U{constructor(t,e,s,i,n){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=e,this._$AM=i,this.options=n,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,e=this,s,i){const n=this.strings;let r=!1;if(void 0===n)t=P(this,t,e,0),r=!c(t)||t!==this._$AH&&t!==M,r&&(this._$AH=t);else{const i=t;let o,l;for(t=n[0],o=0;o<n.length-1;o++)l=P(this,i[s+o],e,o),l===M&&(l=this._$AH[o]),r||(r=!c(l)||l!==this._$AH[o]),l===w?t=w:t!==w&&(t+=(null!=l?l:"")+n[o+1]),this._$AH[o]=l}r&&!i&&this.j(t)}j(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"")}}class L extends U{constructor(){super(...arguments),this.type=3}j(t){this.element[this.name]=t===w?void 0:t}}const k=n?n.emptyScript:"";class R extends U{constructor(){super(...arguments),this.type=4}j(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name)}}class j extends U{constructor(t,e,s,i,n){super(t,e,s,i,n),this.type=5}_$AI(t,e=this){var s;if((t=null!==(s=P(this,t,e,0))&&void 0!==s?s:w)===M)return;const i=this._$AH,n=t===w&&i!==w||t.capture!==i.capture||t.once!==i.once||t.passive!==i.passive,r=t!==w&&(i===w||n);n&&this.element.removeEventListener(this.name,this,i),r&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){var e,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(e=this.options)||void 0===e?void 0:e.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t)}}class D{constructor(t,e,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=e,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t)}}const O={O:r,P:l,A:h,C:1,M:S,L:E,D:A,R:P,I:I,V:U,H:R,N:j,U:L,F:D},V=s.litHtmlPolyfillSupport;null==V||V(B,I),(null!==(t=s.litHtmlVersions)&&void 0!==t?t:s.litHtmlVersions=[]).push("2.7.2");const W=(t,e,s)=>{var i,n;const r=null!==(i=null==s?void 0:s.renderBefore)&&void 0!==i?i:e;let o=r._$litPart$;if(void 0===o){const t=null!==(n=null==s?void 0:s.renderBefore)&&void 0!==n?n:null;r._$litPart$=o=new I(e.insertBefore($(),t),t,void 0,null!=s?s:{})}return o._$AI(t),o},J=t=>(...e)=>({_$litDirective$:t,values:e});class Y{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,s){this._$Ct=t,this._$AM=e,this._$Ci=s}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}const{I:z}=O,Z=()=>document.createComment(""),F=(t,e,s)=>{var i;const n=t._$AA.parentNode,r=void 0===e?t._$AB:e._$AA;if(void 0===s){const e=n.insertBefore(Z(),r),i=n.insertBefore(Z(),r);s=new z(e,i,t,t.options)}else{const e=s._$AB.nextSibling,o=s._$AM,l=o!==t;if(l){let e;null===(i=s._$AQ)||void 0===i||i.call(s,t),s._$AM=t,void 0!==s._$AP&&(e=t._$AU)!==o._$AU&&s._$AP(e)}if(e!==r||l){let t=s._$AA;for(;t!==e;){const e=t.nextSibling;n.insertBefore(t,r),t=e}}}return s},Q=(t,e,s=t)=>(t._$AI(e,s),t),q={},G=t=>{var e;null===(e=t._$AP)||void 0===e||e.call(t,!1,!0);let s=t._$AA;const i=t._$AB.nextSibling;for(;s!==i;){const t=s.nextSibling;s.remove(),s=t}},K=(t,e,s)=>{const i=new Map;for(let n=e;n<=s;n++)i.set(t[n],n);return i},X=J(class extends Y{constructor(t){if(super(t),2!==t.type)throw Error("repeat() can only be used in text expressions")}dt(t,e,s){let i;void 0===s?s=e:void 0!==e&&(i=e);const n=[],r=[];let o=0;for(const e of t)n[o]=i?i(e,o):o,r[o]=s(e,o),o++;return{values:r,keys:n}}render(t,e,s){return this.dt(t,e,s).values}update(t,[e,s,i]){var n;const r=(t=>t._$AH)(t),{values:o,keys:l}=this.dt(e,s,i);if(!Array.isArray(r))return this.ht=l,o;const h=null!==(n=this.ht)&&void 0!==n?n:this.ht=[],a=[];let d,c,u=0,$=r.length-1,p=0,A=o.length-1;for(;u<=$&&p<=A;)if(null===r[u])u++;else if(null===r[$])$--;else if(h[u]===l[p])a[p]=Q(r[u],o[p]),u++,p++;else if(h[$]===l[A])a[A]=Q(r[$],o[A]),$--,A--;else if(h[u]===l[A])a[A]=Q(r[u],o[A]),F(t,a[A+1],r[u]),u++,A--;else if(h[$]===l[p])a[p]=Q(r[$],o[p]),F(t,r[u],r[$]),$--,p++;else if(void 0===d&&(d=K(l,p,A),c=K(h,u,$)),d.has(h[u]))if(d.has(h[$])){const e=c.get(l[p]),s=void 0!==e?r[e]:null;if(null===s){const e=F(t,r[u]);Q(e,o[p]),a[p]=e}else a[p]=Q(s,o[p]),F(t,r[u],s),r[e]=null;p++}else G(r[$]),$--;else G(r[u]),u++;for(;p<=A;){const e=F(t,a[A+1]);Q(e,o[p]),a[p++]=e}for(;u<=$;){const t=r[u++];null!==t&&G(t)}return this.ht=l,((t,e=q)=>{t._$AH=e})(t,a),M}});class tt extends Y{constructor(t){if(super(t),this.et=w,2!==t.type)throw Error(this.constructor.directiveName+"() can only be used in child bindings")}render(t){if(t===w||null==t)return this.ft=void 0,this.et=t;if(t===M)return t;if("string"!=typeof t)throw Error(this.constructor.directiveName+"() called with a non-string value");if(t===this.et)return this.ft;this.et=t;const e=[t];return e.raw=e,this.ft={_$litType$:this.constructor.resultType,strings:e,values:[]}}}tt.directiveName="unsafeHTML",tt.resultType=1;const et=J(tt);var it=i.BJ,st=i.Al,nt=i.dy,ot=i.Jb,rt=i.Ld,lt=i.sY,ht=i.rx,at=i.YP,dt=i.Au;export{it as UnsafeHTMLDirective,st as _$LH,nt as html,ot as noChange,rt as nothing,lt as render,ht as repeat,at as svg,dt as unsafeHTML};let $LH=st,html=nt,noChange=ot,nothing=rt,render=lt,repeat=ht,svg=at,unsafeHTML=dt;

export class CuppaMenu extends CuppaComponent {
	static POSITION = {CENTER:"CENTER", LEFT:"LEFT", LEFT_IN:"LEFT_IN", RIGHT:"RIGHT", RIGHT_IN:"RIGHT_IN", TOP:"TOP", TOP_IN:"TOP_IN", BOTTOM:"BOTTOM", BOTTOM_IN:"BOTTOM_IN"}
	static ARROW = {UP:"UP", LEFT:"LEFT", RIGHT:"RIGHT", DOWN:"DOWN", NONE:"NONE"}
	static ADJUST_TYPE = {OPPOSITE:'OPPOSITE', GAP:'GAP', NONE:'NONE'}
	static attributes = ['target', 'pos-x', 'pos-y', 'force-show', 'force-remove', 'arrow', 'style-arrow', 'contextual-menu', 'adjust-type', 'theme', 'show-on-mouse-over'];
	static observables = ['posX', 'posY', 'arrow', 'adjustType'];
	posX = CuppaMenu.POSITION.RIGHT;
	posY = CuppaMenu.POSITION.TOP_IN;
	arrow = CuppaMenu.ARROW.NONE;
	adjustType = CuppaMenu.ADJUST_TYPE.GAP;
	styleArrow = "";
	target;
	targetElement;
	mainMenu = true;
	contextualMenu = false;
	onMenu = false;
	delayCloseTimeout;
	forceShow = false;
	forceRemove = false;
	groupEvents = `CuppaMenu_${crypto.randomUUID()}`;
	theme = "light";
	showOnMouseOver = false;

	mounted(){
		if(this.parentElement.closest('cuppa-menu')){
			this.mainMenu = false;
		}else{
			this.mainMenu = true;
			this.classList.add('main-menu');
		}
		if(this.target){
			this.targetElement = document.querySelector(this.target);
		}

		this.setPosition();
		setTimeout(()=>{ this.addEvents() }, 200);
	}

	setPosition(autoAdjust = true){
		if(!this.targetElement) return;
		this.style.visibility = 'hidden';
		this.style.display = 'block';
		let dimTarget = this.targetElement.getBoundingClientRect();
		let dim = this.getBoundingClientRect();
		this.style.display = 'none';
		this.style.visibility = 'visible';
		let offset = (this.arrow === CuppaMenu.ARROW.NONE || !this.arrow) ? 0 : 5;
		// x
		let posX = this.posX.toUpperCase();
		if(posX === CuppaMenu.POSITION.CENTER){
			this.style.left = `${dimTarget.x + (dimTarget.width-dim.width)*0.5}px`;
		}else if(posX === CuppaMenu.POSITION.LEFT){
			this.style.left = `${dimTarget.x - dim.width - offset}px`;
		}else if(posX === CuppaMenu.POSITION.LEFT_IN){
			this.style.left = `${dimTarget.x}px`;
		}else if(posX === CuppaMenu.POSITION.RIGHT){
			this.style.left = `${dimTarget.x + dimTarget.width + offset}px`;
		}else if(posX === CuppaMenu.POSITION.RIGHT_IN){
			this.style.left = `${dimTarget.x + dimTarget.width -  dim.width}px`;
		}
		// y
		let posY = this.posY.toUpperCase();
		if(posY === CuppaMenu.POSITION.CENTER){
			this.style.top = `${dimTarget.y + (dimTarget.height-dim.height)*0.5}px`;
		}else if(posY === CuppaMenu.POSITION.TOP){
			this.style.top = `${dimTarget.y - dim.height - offset}px`;
		}else if(posY === CuppaMenu.POSITION.TOP_IN){
			this.style.top = `${dimTarget.y}px`;
		}else if(posY === CuppaMenu.POSITION.BOTTOM){
			this.style.top = `${dimTarget.y + dimTarget.height + offset}px`;
		}else if(posY === CuppaMenu.POSITION.BOTTOM_IN){
			this.style.top = `${dimTarget.y+dimTarget.height-dim.height}px`;
		}
		this.style.display = (this.forceShow) ? 'block' : 'none';
		if(autoAdjust) this.autoAdjust();
	}

	autoAdjust(){
		let dimTarget = cuppa.dim(this.targetElement);
		let dim = cuppa.dim(this);
		let gap = 20;

		if(dim.x < 0){
			if(this.adjustType === CuppaMenu.ADJUST_TYPE.OPPOSITE){
			this.posX = CuppaMenu.POSITION.LEFT_IN;
			}else if(this.adjustType === CuppaMenu.ADJUST_TYPE.GAP){
				this.style.left = `10px`;
			}
		}else if(dim.x + dim.width + gap > window.innerWidth){
			if(this.adjustType === CuppaMenu.ADJUST_TYPE.OPPOSITE){
				this.posX = CuppaMenu.POSITION.RIGHT_IN;
				if(this.refs.arrow){
					let arrowDim = this.refs.arrow.getBoundingClientRect();
					this.refs.arrow.style.left = `calc(100% - ${dimTarget.width*0.5+arrowDim.width*0.5}px)`;
				}
			}else if(this.adjustType === CuppaMenu.ADJUST_TYPE.GAP){
				this.style.left = `${window.innerWidth - dim.width - 10}px`;
			}
		}

		if(dim.y < 0){
			if(this.adjustType === CuppaMenu.ADJUST_TYPE.OPPOSITE){
				this.posY = CuppaMenu.POSITION.BOTTOM;
			}else if(this.adjustType === CuppaMenu.ADJUST_TYPE.GAP){
				this.style.top = `10px`;
			}
		}else if(dim.y + dim.height + gap > window.innerHeight){
			if(this.adjustType === CuppaMenu.ADJUST_TYPE.OPPOSITE){
				this.posY = CuppaMenu.POSITION.TOP;
				this.arrow = CuppaMenu.ARROW.DOWN;
			}else if(this.adjustType === CuppaMenu.ADJUST_TYPE.GAP){
				this.style.top = `${window.innerHeight - dim.height - 10}px`;
			}
		}

		if(this.adjustType === CuppaMenu.ADJUST_TYPE.OPPOSITE){
			this.setPosition(false);
		}
	}

	addEvents(){
		if(this.contextualMenu){
			cuppa.on(window, `click`, this.close, this.groupEvents);
			cuppa.on(window, `scroll`, this.close, this.groupEvents);
			cuppa.on(this.targetElement, `click`, this.show, this.groupEvents);
			if(this.showOnMouseOver) cuppa.on(this.targetElement, `mouseenter`, this.show, this.groupEvents);
		}else if(this.mainMenu){
			cuppa.on(window, `click`, this.close, this.groupEvents);
			cuppa.on(window, `scroll`, this.close, this.groupEvents);
			cuppa.on(this.targetElement, `click`, (e)=>{ this.show(e, true); }, this.groupEvents);
			if(this.showOnMouseOver) cuppa.on(this.targetElement, `mouseenter`, this.show, this.groupEvents);
			cuppa.on(this.targetElement, `mouseenter`, (e)=>{
				let others = this.getOthers({includeContextualMenu:false});
				if(others.length){
					this.closeOthers();
					this.show(e);
				}
			}, this.groupEvents);
		}else{
			cuppa.on(this.targetElement, `click`, e=>e.stopPropagation(), this.groupEvents);
			cuppa.on(this.targetElement, `mouseenter`, this.show, this.groupEvents);
			cuppa.on(this.targetElement, `mouseleave`, this.delayClose, this.groupEvents);
			cuppa.on(this, `mouseenter`, (e)=>{this.onMenu = true}, this.groupEvents);
			cuppa.on(this, `mouseleave`, this.close, this.groupEvents);
		}
	}

	show(e, force = false){
		e.stopPropagation();
		if(this.style.display === 'block' && this.mainMenu){
			if(!this.showOnMouseOver || force) this.style.display = 'none';
		}else{
			this.setPosition();
			if(this.delayCloseTimeout) clearTimeout(this.delayCloseTimeout);
			this.style.display = 'block';
			this.closeOthers();
		}
	}

	closeOthers(){
		if(!this.mainMenu) return;
		let elements = this.getOthers();
		elements.map(element=>element.close());
	}

	getOthers({onlyShowed = true, includeContextualMenu = true} = {}){
		let elements = document.querySelectorAll('cuppa-menu.main-menu');
		elements = Array.from(elements).filter(element=>{
			if(element === this) return null;
			if(onlyShowed && element.style.display === 'none') return null;
			if(!includeContextualMenu && element.contextualMenu) return null;
			return element;
		});
		return elements || [];
	}

	delayClose(e){
		if(this.delayCloseTimeout) clearTimeout(this.delayCloseTimeout);
		this.delayCloseTimeout = setTimeout(()=>{
			if(!this.onMenu){ this.close(); }
		}, 0)
	}

	close(e){
		if(!this.targetElement || this.forceRemove){
			this.remove();
		}else{
			this.onMenu = false;
			this.style.display = 'none';
		}
	}

	unmounted() {
		cuppa.offGroup(this.groupEvents)
	}

	render(){
		return html`
      ${this.arrow === "" || this.arrow.toUpperCase() === CuppaMenu.ARROW.NONE ? `` : html`
        <svg class="cuppa-menu_arrow ${this.arrow.toLowerCase()}" width="10" height="5" viewBox="0 0 18 9" preserveAspectRatio="none" style="${this.styleArrow}" >
          <path data-name="Icon ionic-md-arrow-dropup" d="M9,22.5l9-9,9,9Z" transform="translate(-9 -13.5)"/>
        </svg>
      `}
      <style>
        :root{
          --cuppa-menu-bg:#fff;
          --cuppa-menu-btn-bg:transparent;
          --cuppa-menu-btn-bg-hover:rgba(0,0,0,0.07);
          --cuppa-menu-btn-color:#333;
          --cuppa-menu-tint:invert(0%) sepia(96%) saturate(21%) hue-rotate(215deg) brightness(96%) contrast(102%);
          --cuppa-menu-shadow:0px 3px 10px rgba(0,0,0,0.1);
          --cuppa-menu-border:1px solid rgba(0, 0, 0, 0.06);
          --cuppa-menu-border-bottom:1px solid rgba(0, 0, 0, 0.02);
          --cuppa-menu-separator:1px solid rgba(0, 0, 0, 0.08);
          --cuppa-menu-shortcut-color:rgba(0, 0, 0, 0.4);
          --cuppa-menu-arrow-color:#fff;
        }

        cuppa-menu[theme=dark] {
          color-scheme: dark;
          --cuppa-menu-bg:#1e1e1e;
          --cuppa-menu-btn-bg-hover:rgba(0,0,0,0.3);
          --cuppa-menu-btn-color:#fff;
          --cuppa-menu-tint:invert(100%) sepia(3%) saturate(4%) hue-rotate(251deg) brightness(115%) contrast(100%);
          --cuppa-menu-border:1px solid rgba(255, 255, 255, 0.06);
          --cuppa-menu-border-bottom:1px solid rgba(255, 255, 255, 0.02);
          --cuppa-menu-separator:1px solid rgba(255, 255, 255, 0.08);
          --cuppa-menu-arrow-color:#1e1e1e;
        }

        cuppa-menu{
          display: block;
	        visibility: visible;
          position: fixed;
          left: 0; top:0;
          border: var(--cuppa-menu-border);
          border-bottom: var(--cuppa-menu-border-bottom);
          padding: 4px 0px;
          min-width:140px;
          white-space:nowrap;
          background: var(--cuppa-menu-bg);
          border-radius: 5px;
          box-shadow: var(--cuppa-menu-shadow);
          z-index: 1;
          margin-top:3px;
        }
        cuppa-menu button{
          border: none;
          outline:none;
          white-space: nowrap;
          width: 100%;
          background: var(--cuppa-menu-btn-bg);
          color: var(--cuppa-menu-btn-color);
          padding: 7px 15px 7px 15px;
          display: flex;
          align-items: center;
          justify-content: space-between;
          flex-wrap: nowrap;
          font-size: 14px;
        }
        cuppa-menu button:hover{ background: var(--cuppa-menu-btn-bg-hover);}
        cuppa-menu hr{ border:none; border-bottom: var(--cuppa-menu-separator); margin:7px 0; }
        cuppa-menu .shortcut{ display: flex; align-items: center; justify-content: flex-end; color:var(--cuppa-menu-shortcut-color); min-width: 60px; padding-left: 20px; }
        cuppa-menu img{ height: 14px; margin-right: 14px; filter: var(--cuppa-menu-tint); }
        cuppa-menu i{ width: 14px; height: 14px; background: no-repeat center; background-size: contain; }
        cuppa-menu i{ margin: 0 14px 0 0; }
        cuppa-menu i.more{
          width: 12px;
          height: 12px;
          filter: var(--cuppa-menu-tint);
          margin:0 0 0 14px;
          background-image: url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ic3ZnLWljb24iIHN0eWxlPSJ3aWR0aDogMWVtOyBoZWlnaHQ6IDFlbTt2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO2ZpbGw6IGN1cnJlbnRDb2xvcjtvdmVyZmxvdzogaGlkZGVuOyIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0zNDEuOTU3MjA5IDk1OS4zNTQ2NzhjLTEyLjg5MzY1OCAwLTI1Ljg0MjU3NS00LjQyNTc5OS0zNi4zODY3MjItMTMuNDY3NzMzLTIzLjQ5MzA2NC0yMC4xMDU5Mi0yNi4yMjQyNjgtNTUuNDI2MzU3LTYuMDY0MTEzLTc4Ljg5MTc5MUw2MDMuOTI5NzM2IDUxMS43ODkxOTlsLTMwNC40MjMzNjEtMzU1LjIwNjk3OGMtMjAuMTYwMTU1LTIzLjQ2NTQzNC0xNy40Mjc5MjgtNTguNzg2ODk0IDYuMDY0MTEzLTc4Ljg5MTc5MSAyMy40Mzc4MDUtMjAuMDI0MDU2IDU4Ljc4Njg5NC0xNy4zNzM2OTMgNzguODM3NTU2IDYuMDY0MTEzbDMzNS42NzUxMzIgMzkxLjYyMDMwNWMxNy45NzQzNzMgMjAuOTUyMTk0IDE3Ljk3NDM3MyA1MS44NzU0ODQgMCA3Mi44Mjc2NzlsLTMzNS42NzUxMzIgMzkxLjYyMDMwNUMzNzMuMzcxNjg2IDk1Mi43MTc1MTQgMzU3LjY5MTU2NSA5NTkuMzU0Njc4IDM0MS45NTcyMDkgOTU5LjM1NDY3OHoiICAvPjwvc3ZnPg==)
        }
        cuppa-menu .cuppa-menu_arrow{ position: absolute; fill:var(--cuppa-menu-arrow-color)  }
        cuppa-menu .cuppa-menu_arrow.up{ top:-4px; left:15px; }
        cuppa-menu .cuppa-menu_arrow.left{ transform: rotate(-90deg); top:15px; left:-7px; }
        cuppa-menu .cuppa-menu_arrow.right{ transform: rotate(90deg); top:15px; right:-7px; }
        cuppa-menu .cuppa-menu_arrow.down{ transform: rotate(180deg); bottom: -4px; left:15px; }
      </style>
		`
	}
}

customElements.define('cuppa-menu', CuppaMenu);
document.defaultView.CuppaMenu = CuppaMenu;

// DEPENDENCIES
let cuppa = {};
/* on / off
    EventManager, Structure
    cuppa.eventGroups =	{ 'groupName':  Map<Element>:[{event:String, callback:Function}, {event:String, callback:Function}, ]
                                        Map<Element>:[{event:String, callback:Function}, {event:String, callback:Function}, ]
*/
cuppa.eventGroups = [];
// Add Event listener
cuppa.on = function(elements, event, callback, groupName, useCapture) {
	if(!elements) return;
	if(!Array.isArray(elements)) elements = [elements];
	cuppa.off(elements, event, callback, groupName); // prevent duplicate events
	if(!groupName) groupName = "default";
	if(useCapture === undefined) useCapture = false;
	if(!cuppa.eventGroups[groupName]) cuppa.eventGroups[groupName] = new Map();
	for(let i = 0; i < elements.length; i++){
		let element = elements[i];
		if(!element) continue;
		if(element.addEventListener) element.addEventListener(event, callback, useCapture);
		let events = cuppa.eventGroups[groupName].get(element);
		if(!events) events = [];
		events.push({event:event, callback:callback});
		cuppa.eventGroups[groupName].set(element, events);
	}
};
// Remove a single event
cuppa.off = function(elements, event, callback, groupName){
	if(!Array.isArray(elements)) elements = [elements];
	if(!groupName) groupName = "default";
	if(!cuppa.eventGroups[groupName]) return;
	if(!elements) return;
	if(event === "removed") event = "DOMNodeRemoved";
	for(let i = 0; i < elements.length; i++){
		let events = cuppa.eventGroups[groupName].get(elements[i]);
		if(!events) break;
		for(let j = events.length-1; j >= 0; j--){
			if(callback){
				if(events[j].event === event && events[j].callback === callback ){
					elements[i].removeEventListener(events[j].event, events[j].callback);
					events.splice(j, 1);
					break;
				};
			}else{
				if(events[j].event === event ){
					elements[i].removeEventListener(events[j].event, events[j].callback);
					events.splice(j, 1);
				};
			};
		};
		cuppa.eventGroups[groupName].set(elements[i], events);
	};
};

// Remove event by Group
cuppa.offGroup = function(groupName){
	if(!groupName) groupName = "default";
	let map = cuppa.eventGroups[groupName];
	if(!map) return;
	map.forEach(function(events, element) {
		for(let i = 0; i < events.length; i++){
			element.removeEventListener(events[i].event, events[i].callback);
		};
	});
	map["delete"](groupName);
};
// getUUid
cuppa.uuid = function(){
	let d = new Date().getTime();
	if (typeof performance !== 'undefined' && typeof performance.now === 'function'){
		d += performance.now(); //use high-precision timer if available
	}
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
		let r = (d + Math.random() * 16) % 16 | 0;
		d = Math.floor(d / 16);
		return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
	});
};

cuppa.dim = function(element, opts){
	if(!opts) opts = {}
	if(element == undefined || element == "body" ) element = document.body;
	let value = {width:0, height:0, x:0, y:0 };
	// change parents elements
	let parents = cuppa.parents(element);
	let tmpParents = new Array();
	for(let i = 0; i < parents.length; i++){ if( cuppa.css(parents[i], "display") == "none" ) tmpParents.push(parents[i]); }
	if(cuppa.css(element, "display") == "none") tmpParents.push(element);
	cuppa.css(tmpParents, {display:"block", visibility:"hidden"});

	let clientRect = element.getBoundingClientRect();
	let scrollPos = cuppa.scrollPosition(opts.scrollRef);
	let style = getComputedStyle(element);
	// x,y (position from init of document) - not work
	value.x = (window.scrollX) ? clientRect.left + window.scrollX :  clientRect.left + window.pageXOffset;
	value.y = (window.scrollY) ? clientRect.top + window.scrollY : clientRect.top + window.pageYOffset;
	// x2,y2 (position from parent element) - work
	value.x2 = element.offsetLeft;
	value.y2 = element.offsetTop;
	// x3,y3 (fixed position on window) - work
	value.x3 = clientRect.left;
	value.y3 =  clientRect.top;
	// x4,y4 (position from parent element + scroll position) - work
	value.x4 = value.x + scrollPos.x;
	value.y4 =  value.y + scrollPos.x;
	// dimentions, + border, + padding
	value.width = element.offsetWidth;
	value.height = element.offsetHeight;
	// dimentions, - border, - padding
	value.width2 = element.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
	value.height2 = element.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
	// dimentions, - border
	value.width3 = element.clientWidth;
	value.height3 = element.clientHeight;
	// dimentions, + border, + padding, + margin
	value.width4 = element.offsetWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
	value.height4 = element.offsetHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
	// scroll dimensions
	value.scrollWidth = element.scrollWidth;
	value.scrollHeight = element.scrollHeight;
	// client dimentions
	value.clientWidth = element.clientWidth;
	value.clientHeight = element.clientHeight;
	// return parents to default
	cuppa.css(tmpParents, {display:"none", visibility:"visible"});
	return value;
};

// scrollPosition
cuppa.scrollPosition = function(element){
	let pos = {x:0, y:0}
	if(!element || element == "body" || cuppa.elementType(element) == "body" || element == window){
		pos.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
		pos.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
	}else{
		pos.x = element.scrollLeft;
		pos.y = element.scrollTop;
	};
	return pos;
};

cuppa.css = function(elements, property, opts){
	if(!elements) return;
	elements = cuppa.element(elements);
	for(let k = 0; k < elements.length; k++){
		let element = elements[k];
		if(typeof(property) == "object"){
			if(!Array.isArray(element)) element = [element];
			for(let i = 0; i < element.length; i++){
				for (let css in property) {
					let value = property[css];
					let priority = "";
					if(value){
						value = String(value);
						if(value.indexOf("!important") != -1){
							priority = "important";
							value = value.replace("!important", "");
						};
						element[i].style.setProperty( cuppa.trim(css), cuppa.trim(value), priority);
					};
				};
			};
		}else{
			// opts default
			opts = opts || {};
			opts.number = opts.number || false;
			// get value
			let value;
			try{
				let style = window.getComputedStyle(element);
				value = style.getPropertyValue(property);
				if(opts.number) value = parseFloat(value) || 0;
			}catch(err){ value = null; };
			return value;
		};
	};
};

cuppa.nodeType = function(element){ return  element.nodeName.toLowerCase(); };
cuppa.elementType = function(element){ return cuppa.nodeType(element); };


cuppa.parents = function(ref, opts){
	opts = cuppa.mergeObjects([{reverse:false, type:""}, opts]);
	let element = cuppa.element(ref)[0];
	if(!element) return;
	let parents = [];
	if(cuppa.elementType(element) === "body") return parents;
	while (element) {
		if(element.toString() !== "[object HTMLDocument]" && element.toString() !== "[object HTMLHtmlElement]"){
			if(opts.type){
				if(cuppa.elementType(element) === opts.type){
					parents.push(element);
				}
			}else{
				parents.push(element);
			}
		};
		element = element.parentNode;
	};
	parents.shift();
	if(opts.reverse) parents = parents.reverse();
	return parents;
};


cuppa.mergeObjects = function(array_objs, create_new_object){
	if(!create_new_object){
		let obj1 = array_objs.shift();
		for(let i = 0; i < array_objs.length; i++){
			let obj = array_objs[i];
			if(obj){ for (let attrname in obj) { obj1[attrname] =  obj[attrname]; } }
		};
		return obj1;
	}else{
		let tmp_obj = {};
		for(let i = 0; i < array_objs.length; i++){
			let obj = array_objs[i];
			if(obj){ for (let attrname in obj) { tmp_obj[attrname] = obj[attrname]; } }
		};
		return tmp_obj;
	};
};

cuppa.element = function(ref, opts){
	if(!ref) return;
	opts = opts || {}
	opts.returnType = opts.returnType || "all";
	opts.query = opts.query || true;
	if(opts.target) opts.parent = opts.target;
	if(ref === "body"){
		if(opts.returnType === "first") return document.body;
		else if(opts.returnType === "last") return document.body;
		else return [document.body];
	}else if(Array.isArray(ref)){
		if(opts.returnType === "first") return ref.shift();
		else if(opts.returnType === "last") return ref.pop();
		else return ref;
	}else if(ref.toString() === "[object NodeList]" || ref.toString() === "[object HTMLCollection]"){
		ref = Array.from(ref);
		if(opts.returnType === "first") return ref.shift();
		else if(opts.returnType === "last") return ref.pop();
		else return ref;
	}else if(typeof(ref) === "object"){
		if(opts.returnType === "first") return ref;
		else if(opts.returnType === "last") return ref;
		else return [ref];
	};

	if(!opts.parent || opts.parent === "body") opts.parent = [document.body];
	if(typeof(opts.parent) === "string") opts.parent = cuppa.element(opts.parent);
	if(!Array.isArray(opts.parent)) opts.parent = [opts.parent];

	let nodes = []; if(!opts.parent) return nodes;
	for(let i = 0; i < opts.parent.length; i++){
		let t = opts.parent[i];
		let n = null;
		if(cuppa.search("#", ref) && !opts.query){
			let e = cuppa.replace(ref, "#", "");
			try{ n = t.getElementById(e); }catch(err){  }
			if(n) nodes.push(n);
		}else if(cuppa.search(".", ref) && !opts.query){
			ref = cuppa.replace(ref, "\\.", "");
			try{ n = Array.from(t.getElementsByClassName(ref)); }catch(err){  }
			if(n && n.length) nodes= nodes.concat(n);
		}else{
			try{ n = Array.from(t.querySelectorAll(ref)); }catch(err){  }
			if(n && n.length) nodes= nodes.concat(n);
		};
	};
	if(opts.not) nodes = nodes.filter(function(item){ if(item !== opts.not){ return item; }else{ return null; } });
	if(opts.reverse || opts.invert) nodes.reverse();
	if(opts.returnType === "first") return nodes.shift();
	else if(opts.returnType === "last") return nodes.pop();
	else return nodes;
};

cuppa.trim = function(string){
	if(string) return string.replace(/^\s+|\s+$/g, '');
	else return "";
};
